trigger:
- main

pool:
  vmImage: 'windows-latest'

variables:
  buildConfiguration: 'Release'
  solution: '**/*.sln'

steps:
- checkout: self
  fetchDepth: 0

- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '8.x'

- pwsh: |
    Remove-Item -Recurse -Force artifacts -ErrorAction SilentlyContinue
    New-Item -ItemType Directory -Force -Path artifacts | Out-Null
  displayName: 'Prepare artifacts folder'

- pwsh: |
    $projects = @(
      "src/RuleEngine.Core/RuleEngine.Core.csproj",
      "src/RuleEngine.Sqlite/RuleEngine.Sqlite.csproj",
      "src/CampaignEngine.Core/CampaignEngine.Core.csproj"
    )

    $first = $projects[0]
    $content = Get-Content $first -Raw

    $m = [regex]::Match($content, "<Version>([^<]+)</Version>")
    if (-not $m.Success) { throw "Version tag not found in $first" }

    $current = $m.Groups[1].Value.Trim()
    $parts = $current.Split('.')
    if ($parts.Count -lt 3) { throw "Version format unexpected: $current" }

    $new = "{0}.{1}.{2}" -f $parts[0], $parts[1], ([int]$parts[2] + 1)

    Write-Host "Current version: $current"
    Write-Host "New version: $new"

    foreach ($p in $projects) {
      $raw = Get-Content $p -Raw
      $updated = $raw.Replace("<Version>$current</Version>", "<Version>$new</Version>")
      if ($updated -eq $raw) {
        throw "Could not update Version in $p (expected <Version>$current</Version>)"
      }
      Set-Content -Path $p -Value $updated -NoNewline
      Write-Host "Updated $p"
    }

    Write-Host "##vso[task.setvariable variable=NEW_VERSION]$new"
  displayName: 'Bump patch version in csproj files'

- pwsh: |
    dotnet restore "$(solution)"
    dotnet build "$(solution)" -c "$(buildConfiguration)" --no-restore
  displayName: 'Restore and build solution'

- pwsh: |
    $projects = @(
      "src/RuleEngine.Core/RuleEngine.Core.csproj",
      "src/RuleEngine.Sqlite/RuleEngine.Sqlite.csproj",
      "src/CampaignEngine.Core/CampaignEngine.Core.csproj"
    )

    foreach ($p in $projects) {
      dotnet pack $p -c "$(buildConfiguration)" --no-build -o artifacts
    }
  displayName: 'Pack projects (nupkg -> artifacts)'

- pwsh: |
    if ([string]::IsNullOrWhiteSpace($env:NUGET_API_KEY)) {
      Write-Host "Skipping NuGet push (NUGET_API_KEY not set)"
      exit 0
    }

    $pkgs = Get-ChildItem -Path artifacts -File |
      Where-Object {
        $_.Name.EndsWith(".nupkg") -and
        -not $_.Name.EndsWith(".snupkg") -and
        -not ($_.Name -match "\.symbols\.nupkg$")
      }

    foreach ($pkg in $pkgs) {
      Write-Host "Pushing $($pkg.Name)..."
      dotnet nuget push $pkg.FullName `
        --api-key "$env:NUGET_API_KEY" `
        --source "https://api.nuget.org/v3/index.json" `
        --skip-duplicate
    }
  env:
    NUGET_API_KEY: $(NUGET_API_KEY)
  displayName: 'Push packages to NuGet'
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))

- pwsh: |
    if ([string]::IsNullOrWhiteSpace($env:GITHUB_TOKEN)) {
      Write-Host "Skipping GitHub release (GITHUB_TOKEN not set)"
      exit 0
    }

    $remote = git config --get remote.origin.url
    if ([string]::IsNullOrWhiteSpace($remote) -or ($remote -notmatch "github\.com")) {
      Write-Host "Skipping GitHub release (remote is not GitHub): $remote"
      exit 0
    }

    $newVersion = "$(NEW_VERSION)"
    if ([string]::IsNullOrWhiteSpace($newVersion)) { throw "NEW_VERSION is empty" }

    $repo = $null
    if ($remote -match "github\.com[:/](.+?)(\.git)?$") { $repo = $matches[1] }
    if ([string]::IsNullOrWhiteSpace($repo)) { throw "Cannot parse GitHub repo from remote: $remote" }

    $bodyLines = @(
      "Release v$newVersion",
      "",
      "Packages:",
      "- Minima.RuleEngine.Core v$newVersion",
      "- Minima.RuleEngine.Sqlite v$newVersion",
      "- Minima.CampaignEngine.Core v$newVersion"
    )
    $notes = ($bodyLines -join "`n")

    $payload = @{
      tag_name   = "v$newVersion"
      name       = "Release v$newVersion"
      body       = $notes
      draft      = $false
      prerelease = $false
    } | ConvertTo-Json -Depth 10

    $headers = @{
      Authorization = "token $env:GITHUB_TOKEN"
      "User-Agent"  = "AzureDevOpsPipeline"
      Accept        = "application/vnd.github+json"
    }

    $uri = "https://api.github.com/repos/$repo/releases"
    Invoke-RestMethod -Method Post -Uri $uri -Headers $headers -Body $payload -ContentType "application/json" | Out-Null

    Write-Host "GitHub release created: v$newVersion"
  env:
    GITHUB_TOKEN: $(GITHUB_TOKEN)
  displayName: 'Create GitHub Release'
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: 'artifacts'
    ArtifactName: 'nuget-packages'
    publishLocation: 'Container'
  displayName: 'Publish artifacts'